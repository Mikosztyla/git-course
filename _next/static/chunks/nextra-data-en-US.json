{"/":{"title":"Index","data":{"tematy#Tematy":"Co to jest ten cały \"Git\"?\nPiersze kroki\nCo to jest Gitignore","użyteczne-pliki#Użyteczne pliki":"Spis najważniejszych komend"}},"/commands":{"title":"Commands","data":{"lista-najważniejszych-komend-git-owych#Lista najważniejszych komend Git-owych:":"","git-init#git init":"Tworzy nowe repozytorium Git w bieżącym katalogu.\ngit init","git-clone#git clone":"Kopiuje zdalne repozytorium na lokalny komputer.\ngit clone <URL> [<nazwa_katalogu>]\n--depth <n>: Pobiera tylko ostatnie <n> commitów, co przyspiesza klonowanie (np. przy dużych repozytoriach).\n--branch <branch_name>: Klonuje konkretną gałąź.","git-add#git add":"Dodaje pliki do obszaru staging (do kolejnego commitu).\ngit add <plik>          # Dodaje pojedynczy plik\r\ngit add .               # Dodaje wszystkie zmienione pliki\r\ngit add -A              # Dodaje wszystkie pliki (zależnie od wersji Git może być tożsamy z `git add .`)","git-commit#git commit":"Tworzy nowy commit z plikami dodanymi do staging.\ngit commit -m \"<wiadomość>\"\n-m \"<wiadomość>\": Dodaje wiadomość opisującą commit (krótką i opisową).\n-a: Automatycznie dodaje wszystkie zmienione i śledzone pliki do commitu.\n--amend: Zmienia ostatni commit (używane np. do poprawy wiadomości lub dodania plików).","git-status#git status":"Pokazuje aktualny status repozytorium: zmodyfikowane, usunięte pliki oraz pliki w staging.\ngit status","git-push#git push":"Wysyła lokalne commity do zdalnego repozytorium.\ngit push <zdalne_repo> <gałąź>\n-u <remote> <branch>: Ustawia domyślny zdalny dla gałęzi (pierwsze push wymaga tej flagi, kolejne mogą być git push).\n--force lub -f: Wymusza push (stosowane ostrożnie, ponieważ zmiany w zdalnym repozytorium).\npush --force nadpisze zdalne repozytorium lokalną wersją gałęzi.\nPo wykonaniu dostaniesz pytanie Czy na pewno chcesz to zrobić?, więc tak, dość niebezpieczna operacja.","git-pull#git pull":"Pobiera i łączy zmiany ze zdalnego repozytorium z lokalną gałęzią.\ngit pull <zdalne_repo> <gałąź>\n--rebase: Używa rebase zamiast merge, co pozwala na liniową historię zmian.","git-fetch#git fetch":"Pobiera zmiany ze zdalnego repozytorium, ale ich nie łączy. Przydatne do sprawdzenia, jakie zmiany zaszły w zdalnym repo.\ngit fetch <zdalne_repo>","git-branch#git branch":"Zarządza gałęziami w repozytorium.\ngit branch               # Wyświetla listę lokalnych gałęzi\r\ngit branch <nazwa>       # Tworzy nową gałąź\r\ngit branch -d <nazwa>    # Usuwa gałąź (jeśli jest już zmergowana)\n-D <branch_name>: Wymusza usunięcie gałęzi, nawet jeśli nie została zmergowana.","git-checkout#git checkout":"Przełącza się między gałęziami lub przywraca pliki do określonego stanu.\ngit checkout <gałąź>\r\ngit checkout <plik>      # Przywraca plik do ostatniego commitu\n-b <nowa_gałąź>: Tworzy nową gałąź i od razu się na nią przełącza.","git-merge#git merge":"Łączy zmiany z jednej gałęzi do bieżącej gałęzi.\ngit merge <gałąź>\n--no-ff: Tworzy merge commit nawet w przypadku, gdy możliwe jest szybkie połączenie (fast-forward).\n--abort: Anuluje merge, jeśli wystąpiły konflikty.","git-rebase#git rebase":"Przenosi zmiany na bieżącej gałęzi na szczyt innej gałęzi. Przydatne do tworzenia bardziej liniowej historii.\ngit rebase <gałąź>\n--interactive lub -i: Pozwala na interaktywne przenoszenie commitów (re-ordering, zmiany w historii).\n--continue: Kontynuuje rebase po rozwiązaniu konfliktów.\n--abort: Anuluje rebase i przywraca stan sprzed jego rozpoczęcia.","git-reset#git reset":"Przestawia bieżący HEAD na wybrany commit.\ngit reset <commit>\n--soft: Przenosi HEAD na wybrany commit, ale zostawia zmiany w staging.\n--mixed: Przenosi HEAD na wybrany commit i usuwa zmiany ze staging, ale pozostawia je w katalogu roboczym.\n--hard: Przenosi HEAD na wybrany commit, całkowicie usuwając zmiany ze staging i katalogu roboczego.","git-log#git log":"Wyświetla historię commitów.\ngit log\n--oneline: Wyświetla uproszczoną wersję logu, gdzie każdy commit to jedna linia.\n--graph: Wyświetla historię w formie graficznego drzewa.\n-p: Pokazuje zmiany (diff) dla każdego commitu.\nWciśnij q, żeby przerwać wyświetlanie","git-stash#git stash":"Zapisuje bieżące zmiany w pamięci tymczasowej, umożliwiając tymczasowe przeniesienie się na czystą gałąź.\ngit stash              # Zapisuje bieżące zmiany w stash\r\ngit stash pop          # Przywraca ostatni stash i usuwa go\r\ngit stash list         # Wyświetla listę staszy\nTe polecenia stanowią podstawę codziennej pracy z Git-em. Wszystkie komendy i ich paramentry są raczej ciężkie do zapamiętania, ale na pewno warto wiedzieć, że takie istnieją. Wtedy, będziemy już mogli do Chata-GPT wpisać bardziej konkretne pytanie 😉.Nawet, jeśli przesiądziesz się na jakieś GUI, to i tak warto je znać, bo może się zdażyć, że twój problem jak coś zepsujesz (a zepsujesz, gwarantuje Ci to 😂), 10 razy łatwiej będzie rozwiązać wierszem poleceń."}},"/topics/01-introduction/01-history":{"title":"01 History","data":{"trochę-historii#Trochę historii":"Git został stworzony przez Linusa Torvaldsa.\r\nPierwsza wersja Git-a została wydana 7 kwietnia 2005 roku."}},"/topics/01-introduction/02-control-version":{"title":"02 Control Version","data":{}},"/topics/02-basics/01-first-repo":{"title":"Stworzenie pierwszego repozytorium","data":{"":"Zacznijmy od podstaw podstaw - sprawdź czy masz Git-a. Otwórz ulubiony wiersz poleceń i wykonaj komendę:\n  git -v\nJeżeli wyświetli się coś innego niż błąd, to lecimy dalej.\nJeżeli nie to pobierz Git-a.","konfiguracja-git-a#Konfiguracja Git-a":"Na początku musisz zdefiniować kim jesteś. Kim jesteś dla Git-a oczywiście.Ustaw swoje imię za pomocą komendy:\n  git config --global user.name \"Twoje imie\"\ni swój e-mail:\n  git config --global user.email \"twoj.mail@example.com\"\nBędą to twoje dane używane do zidentyfikowania autora \"commita\" - co to \"commit\" dowiemy się za chwile.\r\nSprawdź czy wszystko się zgadza:\n  git config user.name\r\n  git config user.email","tworzenie-repozytorium#Tworzenie repozytorium":"Teraz możemy już stworzyć swoje pierwsze repozytorium. Ale co to tak na prawdę jest to repozytorium?\nRepozytorium (w slangu \"repo\") to taki folder plików na sterydach. Również przechowuje on pliki lub podfoldery twoje projektu, ale umożliwia on pracę z Git-em. Rozróżniamy 2 typy:\nlokalne repozytorium (local repository) - jest to stan plików projektu znajdujących się u Ciebie lokalnie na komputerze\nzdalne repozytorium (remote repository) - jest to aktualny stan plików projektu w chmurze\nDość gadania, tworzymy lokalne repo:\n  git init\nTak, to tyle, gratulacje! Pierwsze repo stworzone 😆.Zobacz, że w folderze, gdzie to repo zostało stworzony folder .git. Dzięki temu działa cała magia Git-a, ale NIE będziemy tam w środku nic edytować. Zostawiamy go w spokoju. Serio."}},"/topics/01-introduction":{"title":"Index","data":{"co-to-jest-ten-cały-git#Co to jest ten cały \"Git\"?":"Git – rozproszony system kontroli wersji, który pozwala na niezależne zmiany w jednym kodzie, prowadzone w różnych gałęziach\nTak, takie coś wyskakuje jako pierwsze po wpisaniu definicja git-a do wyszukiwarki Googla. Czy jest to zrozumiałe?\r\nNo może dla osoby, która coś z Git-a już wie, ale czy ktoś kto pierwszy raz usłyszał ten zwrot 2 minuty to ogarnie? - Wątpię.\nJeśli jesteś właśnie tą nową osobą - Nie zniechęcaj się!!!\nGit na początku jest dość ciężki do załapania, ale uwierz mi - WARTO!\nGit to takie narzędzie, które pozwala nam zapisywać różne wersje swojego projektu...\nTak, wiem, brzmi jak zwyłe Ctrl + s, ale uwierz mi, że jest to dużooo lepsze. Dlaczego, między innymi dlatego, że\nmożemy w każdej chwili wrócić do wersji projektu, którą kiedyś zapisaliśmy.\nmożemy równolegle tworzyć kilka wersji tego samego projektu.\nmożemy porównywać zmiany w naszym projekcie w stosunku do poprzednich wersji.\nmożemy pracować nad tym samym projektem nie tylko samemu, ale w dowolną liczbę osób i nie musimy się martwić o nadpisywanie swoich wzajebnych postępów.\nJeśli chcesz już przejść do nauki samego narzędzia, to zapraszam tutaj.\nDalej, w tej cześci, będzie trochę historycznych faktów 😉"}},"/topics/02-basics":{"title":"Index","data":{"podstawy-git-a#Podstawy Git-a":"W tej części wykonamy sobie kilka podstawowych operacji, które będą absolutną podstawą używania Git-a.","plan-działania#Plan działania":"stworzenie pierwszego \"repo\"\npierwszy \"komit\"\npierwszy \"pusz\"\nnowy \"brancz\" - nowe przygody\nstajemy się jednością - \"merdż\"\nwojna i same \"konflikty\"\n\"Rzepka\" Julian Tuwim - \"pul\" rzepkę\nSPOJLER\nBędzie fajnie 😎"}},"/topics/03-gitignore":{"title":"Gitgnore","data":{}},"/topics/02-basics/03-first-push":{"title":"Pierwszy \"pusz\"","data":{"":"Ten krok w teorii jest pomijalny, jeśli chcemy pracować z Git-em jedynie lokalnie. W takim wypadku i tak polecam zapoznanie się z treścią poniżej.Jeżeli jednak dalej to czytasz, to zaczynamy.\nPush to przeniesienie zmian ze swojego lokalnego repozytorium, na zdalne.\nAle zanim to zrobimy, to musimy mieć gdzie te zmiany wysłać, czyli musimy mieć zdalne repozytorium. W tym przykładzie zrobimy to za pomocą GitHub-a.","tworzenie-zdalnego-repozytorium#Tworzenie zdalnego repozytorium":"Do dalszej części potrzebujesz konta na GitHub-ie. Jeśli jeszcze go nie masz, załóż je teraz.\nPo zalogowaniu, kliknij w prawym górnym rogu na ikonę swojego profilu i wybierz opcję Your repositories.\nNastępnie na przycisk 📘 New.Teraz znajdujemy się już w panelu konfigurancji zdalnego repozytorium. Zacznij od wybrania nazwy - może być taka sama jak repozytorium lokalnego, ale nie musi.\r\nPole Description, tak jak nazwa wskazuje, będzie opisem co zawiera się w tym repozytorium - jeśli chcesz, możesz uzupełnić./\r\nNastępnie musisz wybrać czy Twoje zdalne repozytorium będzie:\npubliczne (public) - każdy może je zobaczyć, Ty wybierasz kto może commit-ować\nprywatne (private) - Ty wybierasz kto może je zobaczyć i kto może commit-ować\r\nNa ten moment, co wybierzesz zależy wyłącznie od Ciebie.\nNIE inicjalizuj repozytorium z plikiem README.md. Ten checkbox jest bazowo odznaczony - nie ruszaj go.\nResztę opcji pomijamy (później będzie o nich więcej) i klikamy Create repository.Pierwsze zdalne repozytorium stworzone 😎","inizjalizacja-zdalnego-repozytorium#Inizjalizacja zdalnego repozytorium":"Super, fajnie. Stworzyliśmy sobie zdalne repozytorium, ale jest ono totalnie puste. Nie ma w sobie absolutnie nic. Mamy do niego tylko link, którym za chwilę się posłużymy.Ponieważ na ten moment jedyne co mamy to zarezerwowane miejsce w internecie na nasze zdalne repozytorium, chcemy je zaicjalizować (najlepiej naszym lokalnym, które już zrobiliśmy).\nAby to zrobić, musimy najpierw stworzyć połączenie, pomiędzy naszej lokalnym, a zdalnym repozytorium.Na GitHubi-e, prawdopodobnie gdzieś na środku ekranu pojawił się właśnie ten link, do Twojego zdalnego repozytorium. Skopiuj go teraz, będzie nam potrzebny.\nTen link musi mieć na końcu .git.\nPierwsze co zrobimy, to powiemy Git-owi, gdzie jest nasze zdalne repozytorium:\n  git remote add origin <skopiowany_link_do_zdalnego_repo>\norigin to ogólnie przyjęta nazwa na zdalne repo. Będzie jej łatwiej używać, niż za każdym razem kopiować ten długi link.Połączenie stworzymy od razu push-ując zmiany na nasze zdalne repozytorium:\n  git push --set-upstream origin master\nPo wykonaniu tej komendy:\n    Enumerating objects: 3, done.\r\n    Counting objects: 100% (3/3), done.\r\n    Writing objects: 100% (3/3), 216 bytes | 216.00 KiB/s, done.\r\n    Total 3 (delta 0), reused 0 (delta 0), pack-reused 0\r\n    To https://github.com/Mikosztyla/tempDeleteMeLater.git\r\n     * [new branch]      master -> master\r\n    branch 'master' set up to track 'origin/master'.\n--set-upstream musieliśmy robić tylko za pierwszym razem!Każdy następny raz to będzie po prostu git push.\nUdało się! Zainicjalizowaliśmy nasze zdalne repozytorium i pierwszy raz zpush-owaliśmy nasze zmiany. Odśwież teraz stronę GitHub-a i zobacz co się zmieniło."}},"/topics/02-basics/02-first-commit":{"title":"Pierwszy \"komit\"","data":{"":"Commit można porównać do Crl + s - zapisania wersji projektu. Robimy to żeby ustawić sobie taki \"checkpoint\".\nPóźniej będziemy mogli przywrócić starszą wersję projektu lub porównać swoje \"za-commitowane\" zmiany.\nŻeby mieć co zapisać, musimy coś zrobić. Stwórz zwykły plik tekstowy, np test.txt i napisz w nim co tylko Ci się podoba.Ponieważ commit to trochę więcej niż zwykły zapis projektu, musimy się trochę więcej narobić.\nPrzed jego zrobieniem, trzeba na początku wybrać, które pliki się w nim znajdą. Wtedy dopiero zrobimy z nich jeden commit (zapakujemy je w paczkę) i go nazwiemy. Nazwy tych commitów to dość ważna sprawa, bo później po nich najbardziej widać co się dzieje w projekcie, dlatego nazwa \"siemano\", lub \"takie tam cuś\" jest mocno średnia.Dobra, ale zacznijmy od początku","git-status#git status":"git status\nDzięki tej komendzie zobaczymy między innymi, które pliki zawarliśmy już w commit-cie, które możemy zawrzeć itd. Ta komenda pokazuje jeszcze więcej rzeczy, ale nie wszystko na raz.\nJeśli korzystasz z Git Bash-a może to wyglądać mniej więcej tak:\n  $ git status\r\n    On branch main\r\n    Your branch is up to date with 'origin/main'.\r\n\r\n    Changes not staged for commit:\r\n      (use \"git add <file>...\" to update what will be committed)\r\n      (use \"git restore <file>...\" to discard changes in working directory)\r\n            modified:   test.txt\nTak jak możemy wyczytać z komunikatu Changes not staged for commit: - nie wybraliśmy, które pliki zawrzemy w naszym commit-cie.\r\nWidzimy też na czerwono zaznaczony stworzony przez nas plik.","git-add#git add":"Tak jak proponuje nam linijka niżej, wykonajmy komende:\n  git add <twoja_nazwa_pliku>\nTeraz możemy zobaczyć co się zmieniło. jeszcze raz wykonujemy:\n  $ git status\r\n    On branch main\r\n    Your branch is up to date with 'origin/main'.\r\n\r\n    Changes to be committed:\r\n      (use \"git restore --staged <file>...\" to unstage)\r\n            modified:   test.txt\nCo się zmieniło? Prawdopodobnie nasz plik zminił kolor na zielony, co oznacza, że jest on teraz gotowy do zcommit-owania.","git-commit#git commit":"Czeka nas teraz jedno z cięższych zadań - nadanie commit-owi nazwy 😱Dobrą praktyką, jest próba opisania co w tym commit-cie zawieramy lub jaki problem nim rozwiązujemy. W naszym przypadku mogę zaproponować nazwę \"Dodano plik test.txt\".\nWykonaj komendę:\n  git commit -m \"nazwa commitu\"\nRezultat będzie mnie więcej taki:\n$ git commit -m \"nazwa commitu\"\r\n[master (root-commit) baf1278] nazwa commitu\r\n 1 file changed, 1 insertion(+)\r\n create mode 100644 test.txt\nNo i tyle! Pierszy commit zrobiony!\nSpis i dokładniejszy opis najważniejszych komend (między innymi tych, których użyliśmy w tej części) znajduje się tutaj."}},"/topics/02-basics/04-first-branch":{"title":"nowy \"brancz\" - nowe przygody","data":{"":"Branch (gałąź) to, niezależna od reszty, wersja naszego projektu. Umożliwia nam równoległe prowadzenie prac, nie ingerując w inne części projektu.Bardzo, bardzo, ale to bardzo użyteczne w pracach grupowych i nie tylko.\nCała praca z Git-em opiera się na \"branch-ach\", czyli na gałęziach. Nawet teraz w prawie pustym jest już jedna gałąź - master. Jest to domyślna nazwa głównych gałęzi twojego projektu.\nNie różnie się ona zbyt wiele od innych gałęzi, który w przyszłości zostaną stworzone, ale jest w stosunku do niej kilka niepisanych zasad.Na przykład, przyjmuje się, że wersja projektu na masterze powinna być zawsze poprawnie działająca.\r\nNo bo jak to tak. Robisz projekt, trzeba będzie to komuś pokazać i co, pokażesz mu niedziałającą wersję?\r\nTo co ta osoba sobie o Tobie pomyśli? A później jeszcze trzeba będzie szukać po commit-ach gdzie to się zepsuło. No bez sensu.","tworzenie-pierwszej-gałęzi#tworzenie pierwszej gałęzi":"Żeby uniknąć takiej sytuacji, tworzy się gałęzie. Taka gałąź to zupełnie niezależna część Twojego projektu. To trochę tak, jakby wziąć cały projekt\r\ni go skopiować w inne miejsce, żeby tam go edytować - strasznie dużo roboty, a później łączenie to w jedną wersję? Masakra.\\Możesz zobaczyć, na jakiej gałęzi aktualnie jesteś komendą:\n  git branch\nlub w Git Bash-u jest to napisane zawsze w okrągłych nawiasach, np (master)Stwórzmy teraz nową gałąź:\n  git branch <nazwa-gałęzi>\nNo i tyle 😆. Mamy teraz wersję projektu, który możemy niezależnie modyfikować.\nZapytasz może \"No ale jak to, przecież jestem cały czas w tym samym folderze, to jak mogę wykonywć niezależne zmiany?\".No właśnie, na tym polega piękno Git-a","praca-na-nowej-gałęzi#Praca na nowej gałęzi":"Żeby wprowadzić jakieś zmiany na ten naszej nowej super ultra niezależnej wersji projektu, musimy zmienić gałąź, na której pracujemy:\n  git checkout <nazwa-stworzonej-gałęzi>\nTeraz powinniśmy być już na nowej gałęzi. Sprawdź to komendą git branch.To teraz spóbujmy coś zmienić i zobaczmy czy wpłynie to na naszą inną gałąź (po tym co było napisane można by stwierdzić, że \"nie\", ale nie wierz mi na słowo, sprawdź samemu 😉).\nW pliku test.txt wprowadź jakąś zmianę - dopisz coś w nowej linijce, napisz jakąś nową wiadomość, cokolwiek. Zmieniliśmy coś, to trzeba zrobić co? - Commit-a! Tak. Spróbuj samemu.\nPokaż odpowiedź\r\nWażna odpowiedź"}}}