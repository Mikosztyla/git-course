{"/":{"title":"Sekcje","data":{"":"Czym się różni \"pull\" od \"pull request\"?\r\n\"Pull\" to pobranie zmian ze zdalnego repozytorium (z konkretnej gałęzi) na lokalne repozytorium.\r\n\"Pull request\" to funkcjonalność GitHub-a, która jest tak na prawdę prośbą o zmergowanie dwóch gałęzi ze sobą (nie jest dostępna w czystym Git-cie.Pomimo tego, że obie te rzeczy mają w nazwie \"pull\" to nie mają ze sobą zbyt wiele wspólnego 😅"}},"/topics/01-introduction/01-history":{"title":"01 History","data":{"trochę-historii#Trochę historii":"Git został stworzony przez Linusa Torvaldsa.\r\nPierwsza wersja Git-a została wydana 7 kwietnia 2005 roku."}},"/topics/02-basics/01-first-repo":{"title":"Stworzenie pierwszego repozytorium","data":{"":"Zacznijmy od podstaw podstaw - sprawdź czy masz Git-a. Otwórz ulubiony wiersz poleceń i wykonaj komendę:\n  git -v\nJeżeli wyświetli się coś innego niż błąd, to lecimy dalej.\nJeżeli nie to pobierz Git-a.","konfiguracja-git-a#Konfiguracja Git-a":"Na początku musisz zdefiniować kim jesteś. Kim jesteś dla Git-a oczywiście.Ustaw swoje imię za pomocą komendy:\n  git config --global user.name \"Twoje imie\"\ni swój e-mail:\n  git config --global user.email \"twoj.mail@example.com\"\nBędą to twoje dane używane do zidentyfikowania autora \"commita\" - co to \"commit\" dowiemy się za chwile.\r\nSprawdź czy wszystko się zgadza:\n  git config user.name\r\n  git config user.email","tworzenie-repozytorium#Tworzenie repozytorium":"Teraz możemy już stworzyć swoje pierwsze repozytorium. Ale co to tak na prawdę jest to repozytorium?\nRepozytorium (w slangu \"repo\") to taki folder plików na sterydach. Również przechowuje on pliki lub podfoldery twoje projektu, ale umożliwia on pracę z Git-em. Rozróżniamy 2 typy:\nlokalne repozytorium (local repository) - jest to stan plików projektu znajdujących się u Ciebie lokalnie na komputerze\nzdalne repozytorium (remote repository) - jest to aktualny stan plików projektu w chmurze\nDość gadania, tworzymy lokalne repo:\n  git init\nTak, to tyle, gratulacje! Pierwsze repo stworzone 😆.Zobacz, że w folderze, gdzie to repo zostało stworzony folder .git. Dzięki temu działa cała magia Git-a, ale NIE będziemy tam w środku nic edytować. Zostawiamy go w spokoju. Serio."}},"/topics/02-basics/02-first-commit":{"title":"Pierwszy \"komit\"","data":{"":"Commit można porównać do Crl + s - zapisania wersji projektu. Robimy to żeby ustawić sobie taki \"checkpoint\".\nPóźniej będziemy mogli przywrócić starszą wersję projektu lub porównać swoje \"za-commitowane\" zmiany.\nŻeby mieć co zapisać, musimy coś zrobić. Stwórz zwykły plik tekstowy, np test.txt i napisz w nim co tylko Ci się podoba.Ponieważ commit to trochę więcej niż zwykły zapis projektu, musimy się trochę więcej narobić.\nPrzed jego zrobieniem, trzeba na początku wybrać, które pliki się w nim znajdą. Wtedy dopiero zrobimy z nich jeden commit (zapakujemy je w paczkę) i go nazwiemy. Nazwy tych commitów to dość ważna sprawa, bo później po nich najbardziej widać co się dzieje w projekcie, dlatego nazwa \"siemano\", lub \"takie tam cuś\" jest mocno średnia.Dobra, ale zacznijmy od początku","git-status#git status":"git status\nDzięki tej komendzie zobaczymy między innymi, które pliki zawarliśmy już w commit-cie, które możemy zawrzeć itd. Ta komenda pokazuje jeszcze więcej rzeczy, ale nie wszystko na raz.\nJeśli korzystasz z Git Bash-a może to wyglądać mniej więcej tak:\n  $ git status\r\n    On branch main\r\n    Your branch is up to date with 'origin/main'.\r\n\r\n    Changes not staged for commit:\r\n      (use \"git add <file>...\" to update what will be committed)\r\n      (use \"git restore <file>...\" to discard changes in working directory)\r\n            modified:   test.txt\nTak jak możemy wyczytać z komunikatu Changes not staged for commit: - nie wybraliśmy, które pliki zawrzemy w naszym commit-cie.\r\nWidzimy też na czerwono zaznaczony stworzony przez nas plik.","git-add#git add":"Tak jak proponuje nam linijka niżej, wykonajmy komende:\n  git add <twoja_nazwa_pliku>\nTeraz możemy zobaczyć co się zmieniło. jeszcze raz wykonujemy:\n  $ git status\r\n    On branch main\r\n    Your branch is up to date with 'origin/main'.\r\n\r\n    Changes to be committed:\r\n      (use \"git restore --staged <file>...\" to unstage)\r\n            modified:   test.txt\nCo się zmieniło? Prawdopodobnie nasz plik zminił kolor na zielony, co oznacza, że jest on teraz gotowy do zcommit-owania.","git-commit#git commit":"Czeka nas teraz jedno z cięższych zadań - nadanie commit-owi nazwy 😱Dobrą praktyką, jest próba opisania co w tym commit-cie zawieramy lub jaki problem nim rozwiązujemy. W naszym przypadku mogę zaproponować nazwę \"Dodano plik test.txt\".\nWykonaj komendę:\n  git commit -m \"nazwa commitu\"\nRezultat będzie mnie więcej taki:\n$ git commit -m \"nazwa commitu\"\r\n[master (root-commit) baf1278] nazwa commitu\r\n 1 file changed, 1 insertion(+)\r\n create mode 100644 test.txt\nNo i tyle! Pierszy commit zrobiony!\nPamiętaj!Spis i dokładniejszy opis najważniejszych komend (między innymi tych, których użyliśmy w tej części) znajduje się tutaj."}},"/topics/02-basics/03-first-push":{"title":"Pierwszy \"pusz\"","data":{"":"Ten krok w teorii jest pomijalny, jeśli chcemy pracować z Git-em jedynie lokalnie. W takim wypadku i tak polecam zapoznanie się z treścią poniżej.Jeżeli jednak dalej to czytasz, to zaczynamy.\nPush to przeniesienie zmian ze swojego lokalnego repozytorium, na zdalne.\nAle zanim to zrobimy, to musimy mieć gdzie te zmiany wysłać, czyli musimy mieć zdalne repozytorium. W tym przykładzie zrobimy to za pomocą GitHub-a.","tworzenie-zdalnego-repozytorium#Tworzenie zdalnego repozytorium":"Do dalszej części potrzebujesz konta na GitHub-ie. Jeśli jeszcze go nie masz, załóż je teraz.\nPo zalogowaniu, kliknij w prawym górnym rogu na ikonę swojego profilu i wybierz opcję Your repositories.\nNastępnie na przycisk 📘 New.Teraz znajdujemy się już w panelu konfigurancji zdalnego repozytorium. Zacznij od wybrania nazwy - może być taka sama jak repozytorium lokalnego, ale nie musi.\r\nPole Description, tak jak nazwa wskazuje, będzie opisem co zawiera się w tym repozytorium - jeśli chcesz, możesz uzupełnić./\r\nNastępnie musisz wybrać czy Twoje zdalne repozytorium będzie:\npubliczne (public) - każdy może je zobaczyć, Ty wybierasz kto może commit-ować\nprywatne (private) - Ty wybierasz kto może je zobaczyć i kto może commit-ować\r\nNa ten moment, co wybierzesz zależy wyłącznie od Ciebie.\nNIE inicjalizuj repozytorium z plikiem README.md. Ten checkbox jest bazowo odznaczony - nie ruszaj go.\nResztę opcji pomijamy (później będzie o nich więcej) i klikamy Create repository.Pierwsze zdalne repozytorium stworzone 😎","inizjalizacja-zdalnego-repozytorium#Inizjalizacja zdalnego repozytorium":"Super, fajnie. Stworzyliśmy sobie zdalne repozytorium, ale jest ono totalnie puste. Nie ma w sobie absolutnie nic. Mamy do niego tylko link, którym za chwilę się posłużymy.Ponieważ na ten moment jedyne co mamy to zarezerwowane miejsce w internecie na nasze zdalne repozytorium, chcemy je zaicjalizować (najlepiej naszym lokalnym, które już zrobiliśmy).\nAby to zrobić, musimy najpierw stworzyć połączenie, pomiędzy naszem lokalnym, a zdalnym repozytorium.Na GitHubi-e, prawdopodobnie gdzieś na środku ekranu pojawił się właśnie ten link, do Twojego zdalnego repozytorium. Skopiuj go teraz, będzie nam potrzebny.\nTen link musi mieć na końcu .git.\nPierwsze co zrobimy, to powiemy Git-owi, gdzie jest nasze zdalne repozytorium:\n  git remote add origin <skopiowany_link_do_zdalnego_repo>\norigin to ogólnie przyjęta nazwa na zdalne repo. Będzie jej łatwiej używać, niż za każdym razem kopiować ten długi link.Połączenie stworzymy od razu push-ując zmiany na nasze zdalne repozytorium:\n  git push --set-upstream origin master\nPo wykonaniu tej komendy:\n    Enumerating objects: 3, done.\r\n    Counting objects: 100% (3/3), done.\r\n    Writing objects: 100% (3/3), 216 bytes | 216.00 KiB/s, done.\r\n    Total 3 (delta 0), reused 0 (delta 0), pack-reused 0\r\n    To https://github.com/Mikosztyla/tempDeleteMeLater.git\r\n     * [new branch]      master -> master\r\n    branch 'master' set up to track 'origin/master'.\n--set-upstream musieliśmy robić tylko za pierwszym razem!Każdy następny raz to będzie po prostu git push.\nUdało się! Zainicjalizowaliśmy nasze zdalne repozytorium i pierwszy raz zpush-owaliśmy nasze zmiany. Odśwież teraz stronę GitHub-a i zobacz co się zmieniło."}},"/topics/02-basics/04-first-branch":{"title":"Nowy \"brancz\" - nowe przygody","data":{"":"Branch (gałąź) to, niezależna od reszty, wersja naszego projektu. Umożliwia nam równoległe prowadzenie prac, nie ingerując w inne części projektu.Bardzo, bardzo, ale to bardzo użyteczne w pracach grupowych i nie tylko.\nCała praca z Git-em opiera się na \"branch-ach\", czyli na gałęziach. Nawet teraz w prawie pustym jest już jedna gałąź - master. Jest to domyślna nazwa głównych gałęzi twojego projektu.\nNie różnie się ona zbyt wiele od innych gałęzi, który w przyszłości zostaną stworzone, ale jest w stosunku do niej kilka niepisanych zasad.Na przykład, przyjmuje się, że wersja projektu na masterze powinna być zawsze poprawnie działająca.\r\nNo bo jak to tak. Robisz projekt, trzeba będzie to komuś pokazać i co, pokażesz mu niedziałającą wersję?\r\nTo co ta osoba sobie o Tobie pomyśli? A później jeszcze trzeba będzie szukać po commit-ach gdzie to się zepsuło. No bez sensu.","tworzenie-pierwszej-gałęzi#Tworzenie pierwszej gałęzi":"Żeby uniknąć takiej sytuacji, tworzy się gałęzie. Taka gałąź to zupełnie niezależna część Twojego projektu. To trochę tak, jakby wziąć cały projekt\r\ni go skopiować w inne miejsce, żeby tam go edytować - strasznie dużo roboty, a później łączenie to w jedną wersję? Masakra.Możesz zobaczyć, na jakiej gałęzi aktualnie jesteś komendą:\n  git branch\nlub w Git Bash-u jest to napisane zawsze w okrągłych nawiasach, np (master)Stwórzmy teraz nową gałąź:\n  git branch <nazwa-gałęzi>\nNo i tyle 😆. Mamy teraz wersję projektu, który możemy niezależnie modyfikować.\nZapytasz może \"No ale jak to, przecież jestem cały czas w tym samym folderze, to jak mogę wykonywć niezależne zmiany?\".No właśnie, na tym polega piękno Git-a","praca-na-nowej-gałęzi#Praca na nowej gałęzi":"Żeby wprowadzić jakieś zmiany na ten naszej nowej super ultra niezależnej wersji projektu, musimy zmienić gałąź, na której pracujemy:\n  git checkout <nazwa_stworzonej_gałęzi>\nTeraz powinniśmy być już na nowej gałęzi. Sprawdź to komendą git branch.To teraz spóbujmy coś zmienić i zobaczmy czy wpłynie to na naszą inną gałąź (po tym co było napisane można by stwierdzić, że \"nie\", ale nie wierz mi na słowo, sprawdź samemu 😉).\nW pliku test.txt wprowadź jakąś zmianę - dopisz coś w nowej linijce, napisz jakąś nową wiadomość, cokolwiek. Zmieniliśmy coś, to trzeba zrobić co? - Commit-a! Spróbuj samemu.\nPokaż rozwiązanie\ngit add nazwa_pliku\ngit commit -m \"nazwa commita\"\nUpewnij się teraz, że po wpisaniu git status, odpowiedź to:\r\nnothing to commit, working tree clean\nJeśli nie, to przeanalizuj czy wszystko zostało zrobione tak jak w odpowiedzi, jeśli tak to jedziemy dalej.Wróć teraz na master-a:\n  git checkout master\ni podejrzyj zawartość pliku, który przed chwilą był edytowany. I co? Nie ma zmian - czyli teoria niezależności działa 😎.Wróć na nową gałąź:\n  git checkout <nazwa_twojej_gałęzi>\ni upewnij się, że zmiany pliku test.txt z powrotem wróciły.\nTrudność tych kroków wcale nie wzrasta przy większym projekcie i większej ilości zmienianych plików. Uwierz mi (chociaż przed chwilą mówiłem, żeby tego nie robić).\nPamiętaj, że gałąź tworzymy z jakiegoś konkretnego commit-a. Najczęściej jest to najnowsza wersja mastera."}},"/topics/02-basics/05-first-merge":{"title":"Pierwszy \"merdż\"","data":{"":"Merge to połączenie dwóch gałęzi w jedną.\nOk, mamy te dwie wersje projektu, ale teraz z powrotem chcielibyśmy mieć jedną. Mamy w sumie dwie opcje:\nkasujemy naszą nową gałąź i tracimy wszystkie zmiany.\noczywiścia opcja 1. nie wchodzi w grę, musimy zrobić merge.\nPołączymy naszą nową gałąź do głównej gałęzi (mastera).","git-merge#git merge":"Jeśli łączymy dwie gałęzie, to pasowałoby zdefiniować którą łączymy do której. Rozwiązanie jest proste - przechodzimy na gałąź, do której\r\nchcemy przyłączyć zmiany z tej drugiej i wykonujemy komendę. W ten przypadku, mergujemy zmiany do master-a.Musimy więc zacząć od przejścia na master-a. Pamiętasz jak?\nPokaż rozwiązanie\r\ngit checkout master\nJak już jesteśmy na masterze, to robimy:\n  git merge <nasza_druga_gałąź>\nPoprawny wynik:\n    $ git merge newBranch\r\n    Updating baf1278..f7da5d5\r\n    Fast-forward\r\n     test.txt | 3 ++-\r\n     1 file changed, 2 insertions(+), 1 deletion(-)\nMniej więcej coś takiego. No i co? To tyle, udało się. Możesz podglądnąć plik test.txt i zobaczyć, że pomimo tego, że jesteśmy\r\nna masterze, to mamy też zmiany, które wykonaliśmy w zupełnie innym miejscu.Możesz też zobaczyć listę wykonanych commit-ów:\n  git log --oneline\ni zobaczyć, że są dwa, a nie jeden.\ngit merge tworzy automatycznie dodatkowy commit \"łączący\" gałęzie.\nOczywiście, wszystko to co tutaj robisz, robisz lokalnie. Jak zobaczysz na GitHub-a, to nie będzie merga. To dlatego, że nie zaktualizowaliśmy zdalnego repozytorium.\nJeśli chcesz, wykonaj teraz git push i zobacz, że zdalne repozytorium po odświeżeniu strony będzie miała aktualne zmiany."}},"/topics/02-basics/06-first-conflict":{"title":"Wojna i same \"konflikty\"","data":{"":"Ostatni merge poszedł nam szybko, gładko i bezboleśnie. Niestety, nie zawsze tak będzie. Teraz spróbujemy doprowadzić do konfliktu specjalnie,\r\nale raczej cała reszta przypadków będzie zupełnie przypadkowa i niezamierzona (równocześnie nieunikniona).","tworzenie-konfliktu#Tworzenie konfliktu":"Stworzymy sobie dwie nowe gałęzie:\n  git branch <branch_1>\r\n  git branch <branch_2>\nTeraz przejdźmy na jednego z nich, np na branch_. Jaką komendą?\nPokaż rozwiązanie\r\ngit checkout branch_1\nRób dokładnie to, co będzie opisasne poniżej. Wywołanie konfliktu wymaga precyzji.(Tak na prawdę jak zaczniesz pracę z Git-em to konflikty przyjdą same przy większej ilości plików i zmian. Tutaj przykład jest prostszy, więc wymaga precyzji).\nZmień dokładnie pierwszą linijkę w pliku test.txt i żadnej innej.Świetnie, dodaj ten plik za pomocą git add i zrób commit-a git commit (oczywiście z jakąś nazwą).Przepnij się teraz na drugą gałąź 'git checkout branch_2' (drugą stworzoną przed chwilą gałąź) i również zmień tylko pierwszą linijkę w pliku test.txt.Zrób git add i git commit (pamiętaj o nazwie!).Wracamy na master-a git checkout master.\nPrzystępujemy teraz do mergowania.Weź głęboki oddech\n  git merge <branch_1>\nI? (Możesz odetchnąć)\n    $ git merge branch1\r\n    Updating f7da5d5..73e86a5\r\n    Fast-forward\r\n     test.txt | 2 +-\r\n     1 file changed, 1 insertion(+), 1 deletion(-)\nJest git 😎. To teraz drugi branch:\n  git merge <branch_2>\nNo i karamba....\n    $ git merge branch2\r\n    Auto-merging test.txt\r\n    CONFLICT (content): Merge conflict in test.txt\r\n    Automatic merge failed; fix conflicts and then commit the result.\nAutomatic merge failed 😭.Ale spokojnie, damy radę. Podejrzyć zawartość pliku test.txt. Pewnie wygląda mniej więcej tak:\n<<<<<<< HEAD\r\nlinijka z gałęzi 1\r\n=======\r\nlinijka z gałęzi 2\r\n>>>>>>> branch_2\nCzęść pomiędzy <<<<<<<, a =======, czyli linijka z gałęzi 1, to zmiana, która jest aktualnie na masterze (czyli ta z pierwszej gałęzi).\r\nCzęść pomiędzy =======, a >>>>>>>, czyli linijka z gałęzi 2, to zmiana, która przyszła z drugiej gałęzi branch_2.Teraz to my musimy zdecydować, jak ten konflikt rozwiązać. Możemy zostawić tylko zmianę z mastera, tylko zmianę z branch_2, możemy zostawić obie albo\r\nżadnej nie brać. Generalnie definiujemy, jak będzie wyglądał ten plik po mergu. Wyrzucamy wszystkie linie, które zaczynają się od\r\n<<<<<<<, ======= i >>>>>>> i wybieramy co ma zostać. Możemy zostawić obie, wtedy treść pliku test.txt to będzie:\nlinijka z gałęzi 1\r\nlinijka z gałęzi 2\nZapisujemy zmiany i patrzymy co się dzieje git status:\nuser@ path (master|MERGING)\r\n$ git status\r\nOn branch master\r\nYour branch is ahead of 'origin/master' by 2 commits.\r\n  (use \"git push\" to publish your local commits)\r\n\r\nYou have unmerged paths.\r\n  (fix conflicts and run \"git commit\")\r\n  (use \"git merge --abort\" to abort the merge)\r\n\r\nUnmerged paths:\r\n  (use \"git add <file>...\" to mark resolution)\r\n        both modified:   test.txt\r\n\r\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\nZacznijmy od tego, że teraz już nie mamy na górze (master), tylko (master)|MERGING, co oznacza, że jesteśmy w trakcie mergu.\r\nDopóki nie rozwiążemy wszystkich konfliktów, mało co będziemy mogli zrobić.My już konflikt rozwiązaliśmy, teraz tylko trzeba powiedzieć Git-owi, że to zrobiliśmy. Jak widać powyżej, mamy:\nUnmerged paths:\r\n  (use \"git add <file>...\" to mark resolution)\r\n        both modified:   test.txt\nWięc tym razem samemu musisz zrobić git add test.txt i git commit -m \"nazwa commita\".\nOstatnio zrobił to za nas git merge, ponieważ nie było konfliktów. Gdy coś jednak nie przejdzie automatycznie, trzeba wszystko zrobić ręcznie.\nPowinno być teraz coś w stylu:\n$ git commit -m \"nazwa commita\"\r\n[master 0b204dd] nazwa commita\nPodejrzyj teraz zawartość pliku i upewnij się, że są poprawnie zmergowane zmiany.\nProces ten jest dość męczący nawet dla tak niepozornego konfliktu. Wszystko jednak idzie dużo szybciej przy użyciu jakiegoś GUI do Git-a, np\r\nGitKraken albo GitHub Desktop.Dobrze jest też poświęcić chwilę czasu i nerwów na zrozumienie tego procesu, bo później każdy kolejny merge zajmuje mniej i mniej czasu."}},"/topics/02-basics/07-first-pull":{"title":"\"Rzepka\" Julian Tuwim - \"pul\" rzepkę","data":{"":"Pull to ściągnięcie aktualnej wersji zdalnego repozytorium, na lokalne.\nTutaj nie ma już za dużej filozofii git pull pobiera zdalną wersję gałęzi, na której aktualnie się znajdujemy. Jeśli będą konflikty, to już umiesz je rozwiązywać 😎.\r\nJeśli nie, to tylko się cieszyć.\nBardzo dobrą praktyką, jest zawsze robić commit przed zrobieniem git pull. Zapobiegnie to niepotrzebnym nerwom i utraconymi zmianami.\nRównież przy pracy w grupie, częste pull-owanie jest bardzo dobre - nie zdarzy się sytuacja, że stworzymy gałąź od nieaktualnego mastera."}},"/topics/02-basics/08-summary":{"title":"Podsumowanie","data":{"":"Ten poradnik zawierał najbardziej podstawowe komendy do pracy z Git-tem, ale...Według mnie, w zupełności wystarczą one przez 90% czasu. Zrozumienie ich i nabycie wprawy to kwestia czasu 😉.Pomyśl sobie teraz, że robisz coś na jednym komputerze. Tworzysz sobie zdalne repozytorium i push-ujesz na nie zmiany. Później zmieniasz komputer i co?\r\ngit pull i jest.\nDodatkowo, to wszystko działa w mgnieniu oka, więc jest to na prawdę bardzo szybkie.","podsumowanie-komend#Podsumowanie komend":"Komendy, które zawarte były w tym poradniku to:\ngit init - tworzy repozytorium\ngit config - konfiguruje Git-a\ngit remote add - definicja lokalizacji zdalnego repozytorium\ngit add - dodaje pliki/foldery do commit-a\ngit commit - commit-uje zmiany\ngit push - wysłanie zmian na zdalne repozytorium\ngit pull - pobranie zmian ze zdalnego repozytorium\ngit branch nazwa - tworzy gałąź\ngit branch - wyświetla nazwę gałęzi, na której aktualnie pracujesz\ngit checkout - przepina na inną gałąź\ngit merge - inicjuje merge\ngit status - wyświetla status - co się dzieje z plikami w naszym repozytorium i stan naszej gałęzi w stosunku do mastera\nJeżeli masz jeszcze chwilę czasu, wypełnij proszę tę ankietę 🥺.Twoja opinia na temat tego poradnika na pewno bardzo pomoże mi w dalszym jego rozwoju.Dzięki!!!"}},"/topics/02-basics":{"title":"Index","data":{"podstawy-git-a#Podstawy Git-a":"W tej części wykonamy sobie kilka podstawowych operacji, które będą absolutną podstawą używania Git-a.","plan-działania#Plan działania":"stworzenie pierwszego \"repo\"\npierwszy \"komit\"\npierwszy \"pusz\"\nnowy \"brancz\" - nowe przygody\nstajemy się jednością - \"merdż\"\nwojna i same \"konflikty\"\n\"Rzepka\" Julian Tuwim - \"pul\" rzepkę\nSPOJLER\nBędzie fajnie 😎\nBędzie tu pewnie trochę nowych dla ciebie komend. Ich spis i dokładniejszy opis znajduje się tutaj"}},"/topics/03-gitignore":{"title":"Gitignorować = obrażać?","data":{}},"/topics/01-introduction/02-control-version":{"title":"02 Control Version","data":{}},"/commands":{"title":"Commands","data":{"lista-najważniejszych-komend-git-owych#Lista najważniejszych komend Git-owych:":"","git-init#git init":"Tworzy nowe repozytorium Git w bieżącym katalogu.\ngit init","git-clone#git clone":"Kopiuje zdalne repozytorium na lokalny komputer.\ngit clone <URL> [<nazwa_katalogu>]\n--depth <n>: Pobiera tylko ostatnie <n> commitów, co przyspiesza klonowanie (np. przy dużych repozytoriach).\n--branch <branch_name>: Klonuje konkretną gałąź.","git-add#git add":"Dodaje pliki do obszaru staging (do kolejnego commitu).\ngit add <plik>          # Dodaje pojedynczy plik\r\ngit add .               # Dodaje wszystkie zmienione pliki\r\ngit add -A              # Dodaje wszystkie pliki (zależnie od wersji Git może być tożsamy z `git add .`)","git-commit#git commit":"Tworzy nowy commit z plikami dodanymi do staging.\ngit commit -m \"<wiadomość>\"\n-m \"<wiadomość>\": Dodaje wiadomość opisującą commit (krótką i opisową).\n-a: Automatycznie dodaje wszystkie zmienione i śledzone pliki do commitu.\n--amend: Zmienia ostatni commit (używane np. do poprawy wiadomości lub dodania plików).","git-status#git status":"Pokazuje aktualny status repozytorium: zmodyfikowane, usunięte pliki oraz pliki w staging.\ngit status","git-push#git push":"Wysyła lokalne commity do zdalnego repozytorium.\ngit push <zdalne_repo> <gałąź>\n-u <remote> <branch>: Ustawia domyślny zdalny dla gałęzi (pierwsze push wymaga tej flagi, kolejne mogą być git push).\n--force lub -f: Wymusza push (stosowane ostrożnie, ponieważ zmiany w zdalnym repozytorium).\npush --force nadpisze zdalne repozytorium lokalną wersją gałęzi.\nPo wykonaniu dostaniesz pytanie Czy na pewno chcesz to zrobić?, więc tak, dość niebezpieczna operacja.","git-pull#git pull":"Pobiera i łączy zmiany ze zdalnego repozytorium z lokalną gałęzią.\ngit pull <zdalne_repo> <gałąź>\n--rebase: Używa rebase zamiast merge, co pozwala na liniową historię zmian.","git-fetch#git fetch":"Pobiera zmiany ze zdalnego repozytorium, ale ich nie łączy. Przydatne do sprawdzenia, jakie zmiany zaszły w zdalnym repo.\ngit fetch <zdalne_repo>","git-branch#git branch":"Zarządza gałęziami w repozytorium.\ngit branch               # Wyświetla listę lokalnych gałęzi\r\ngit branch <nazwa>       # Tworzy nową gałąź\r\ngit branch -d <nazwa>    # Usuwa gałąź (jeśli jest już zmergowana)\n-D <branch_name>: Wymusza usunięcie gałęzi, nawet jeśli nie została zmergowana.","git-checkout#git checkout":"Przełącza się między gałęziami lub przywraca pliki do określonego stanu.\ngit checkout <gałąź>\r\ngit checkout <plik>      # Przywraca plik do ostatniego commitu\n-b <nowa_gałąź>: Tworzy nową gałąź i od razu się na nią przełącza.","git-merge#git merge":"Łączy zmiany z jednej gałęzi do bieżącej gałęzi.\ngit merge <gałąź>\n--no-ff: Tworzy merge commit nawet w przypadku, gdy możliwe jest szybkie połączenie (fast-forward).\n--abort: Anuluje merge, jeśli wystąpiły konflikty.","git-rebase#git rebase":"Przenosi zmiany na bieżącej gałęzi na szczyt innej gałęzi. Przydatne do tworzenia bardziej liniowej historii.\ngit rebase <gałąź>\n--interactive lub -i: Pozwala na interaktywne przenoszenie commitów (re-ordering, zmiany w historii).\n--continue: Kontynuuje rebase po rozwiązaniu konfliktów.\n--abort: Anuluje rebase i przywraca stan sprzed jego rozpoczęcia.","git-reset#git reset":"Przestawia bieżący HEAD na wybrany commit.\ngit reset <commit>\n--soft: Przenosi HEAD na wybrany commit, ale zostawia zmiany w staging.\n--mixed: Przenosi HEAD na wybrany commit i usuwa zmiany ze staging, ale pozostawia je w katalogu roboczym.\n--hard: Przenosi HEAD na wybrany commit, całkowicie usuwając zmiany ze staging i katalogu roboczego.","git-log#git log":"Wyświetla historię commitów.\ngit log\n--oneline: Wyświetla uproszczoną wersję logu, gdzie każdy commit to jedna linia.\n--graph: Wyświetla historię w formie graficznego drzewa.\n-p: Pokazuje zmiany (diff) dla każdego commitu.\nWciśnij q, żeby przerwać wyświetlanie","git-stash#git stash":"Zapisuje bieżące zmiany w pamięci tymczasowej, umożliwiając tymczasowe przeniesienie się na czystą gałąź.\ngit stash              # Zapisuje bieżące zmiany w stash\r\ngit stash pop          # Przywraca ostatni stash i usuwa go\r\ngit stash list         # Wyświetla listę staszy\nTe polecenia stanowią podstawę codziennej pracy z Git-em. Wszystkie komendy i ich paramentry są raczej ciężkie do zapamiętania, ale na pewno warto wiedzieć, że takie istnieją. Wtedy będziemy już mogli do Chata-GPT wpisać bardziej konkretne pytanie 😉.Nawet, jeśli przesiądziesz się na jakieś GUI, to i tak warto je znać, bo może się zdażyć, że twój problem jak coś zepsujesz (a zepsujesz, gwarantuje Ci to 😂), 10 razy łatwiej będzie rozwiązać wierszem poleceń."}},"/topics/01-introduction":{"title":"Index","data":{"co-to-jest-ten-cały-git#Co to jest ten cały \"Git\"?":"Git – rozproszony system kontroli wersji, który pozwala na niezależne zmiany w jednym kodzie, prowadzone w różnych gałęziach\nTak, takie coś wyskakuje jako pierwsze po wpisaniu definicja git-a do wyszukiwarki Googla. Czy jest to zrozumiałe?\r\nNo może dla osoby, która coś z Git-a już wie, ale czy ktoś, kto pierwszy raz usłyszał ten zwrot 2 minuty temu, to ogarnie? - Wątpię.\nJeśli jesteś właśnie tą nową osobą - Nie zniechęcaj się!!!\nGit na początku jest dość ciężki do załapania, ale uwierz mi - WARTO!\nGit to narzędzie, które pozwala zapisywać różne wersje swojego projektu...\nTak, wiem, brzmi jak zwyłe Ctrl + s, ale tak na prawdę jest to duuużo lepsze. Dlaczego? Między innymi dlatego, że\nmożemy w każdej chwili wrócić do wersji projektu, którą kiedyś zapisaliśmy.\nmożemy równolegle tworzyć kilka wersji tego samego projektu.\nmożemy porównywać zmiany w naszym projekcie w stosunku do poprzednich wersji.\nmożemy pracować nad tym samym projektem nie tylko samemu, ale w dowolną liczbę osób i nie musimy się martwić o nadpisywanie swoich wzajemnych postępów.\nJeśli chcesz już przejść do nauki samego narzędzia, to zapraszam tutaj.\nDalej, w tej sekcji, będzie trochę historycznych faktów 😉"}}}